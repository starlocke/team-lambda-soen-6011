{"componentChunkName":"component---src-templates-skill-page-template-js","path":"/skills/post-one","result":{"data":{"markdownRemark":{"html":"<p>I've spent a good part of the past two years working on JavaScript-heavy codebases on the client-side of commercial applications and hobbyist projects but about eight months ago, I had made a rather smooth transition to server-side engineering. I currently work nearly entirely with the Ruby on Rails web framework (occasionally with Sinatra) which pushed me into learning its technicalities at greater depth. However, what I had observed was that my learning was more in the style of \"first Rails, then Ruby\". Interestingly, I had realized that I wasn't the only one. The <a href=\"https://www.ruby-lang.org/en/about/\">ruby-lang.org/about</a> page itself says, <em>\"Much of the growth is attributed to the popularity of software written in Ruby, particularly the Ruby on Rails web framework.\"</em></p>\n<p>With the <em>Ruby without Rails</em> movement gaining momentum lately, I've been intrigued not only by the possibilities of using Ruby to build web applications without Rails but also by the nuances of Ruby's internals. This curiosity lead me to find \"Ruby Under A Microscope\" by Pat Shaughnessy and attempt to study it. I hope to serialize my study notes as posts covering sizable chunks of content from the book every week. These posts will not just be summarized versions of chapters but rather documented experiences of my poking around parts of the Ruby Language's source (available on GitHub) and trying to make sense of it.</p>\n<h2><em>Flavors</em> of Ruby</h2>\n<p>While Ruby, in its official distribution today, uses YARV (for ruby versions <code>&#x3C; 1.9</code>), Ruby does have implementations that utilize other compiler backends:</p>\n<ul>\n<li><strong>JRuby</strong> is Ruby atop the JVM (Java Virtual Machine), utilizing the JVM’s optimizing JIT compilers, garbage collectors, concurrent threads, tool ecosystem, and vast collection of libraries.</li>\n<li><strong>Rubinius</strong> is ‘Ruby written in Ruby’. Built on top of LLVM, Rubinius sports a nifty virtual machine that other languages are - being built on top of, too.</li>\n<li><strong>TruffleRuby</strong> is a high performance Ruby implementation on top of GraalVM.</li>\n<li><strong>mruby</strong> is a lightweight implementation of the Ruby language that can be linked and embedded within an application. Its development is led by Ruby’s creator Yukihiro “Matz” Matsumoto.</li>\n<li><strong>IronRuby</strong> is an implementation “tightly integrated with the .NET Framework”.</li>\n<li><strong>MagLev</strong> is “a fast, stable, Ruby implementation with integrated object persistence and distributed shared cache”.</li>\n<li><strong>Cardinal</strong> is a “Ruby compiler for Parrot Virtual Machine” (Perl 6).</li>\n</ul>\n<h2>Ruby Implementations : A Little Bit of History</h2>\n<p>MRI (Matz's Ruby Interpreter), which was also known as CRuby and named after Ruby's creator Yukihiro “Matz” Matsumoto, was the <em>de facto</em> reference implementation of the Ruby Programming Language until Ruby 1.9 when the attempt to create a specification (RubySpec) failed. MRI was a pure interpreter which in simple terms: ingested Ruby code; tokenized; created an Abstract Syntax Tree (AST), as a consequence of parsing and then executed Ruby's C code.</p>\n<p>Digressing to the <em>Global Interpreter Lock (GIL)</em>, which cannot go unmentioned when talking of MRI because of its criticism for the way concurrency was handled in a time when multi-core processors and implementations of true multi-threading became a necessity. But I'd suppose concurrency in Ruby would require a post of its own.</p>\n<p>The book has a focus primarily on this implementation of Ruby while <em>Chapter 3</em> on compilation gets into the details of <em>YARV / RubyVM</em> which is the official distribution of Ruby today.</p>\n<h3>The RubySpec project</h3>\n<p>The official <a href=\"https://github.com/ruby/spec\">ruby/spec</a> is a test suite for the behavior of the Ruby programming language. As stated on its official GitHub page, it is not ISO standardized and does not seek standardization of that kind but instead just is a practical tool to test the behaviour of Ruby with code. These tests are written in the style of RSpec 2 but are run with MSpec and describe - <em>language syntax, core library, the standard library, the C API for extensions and the command line flags</em>.\nThe RubySpec tests were initially created in 2006 for the Rubinius project.</p>\n<h2>Tokenization</h2>\n<p>A standard Ruby program (ruby version > 1.9) would undergo three transforms before it is run:</p>\n<ol>\n<li>Tokenization --> Tokens</li>\n<li>Parsing --> Abstract Synatax Tree nodes</li>\n<li>Compilation --> YARV instructions</li>\n</ol>\n<p>Clearly, this excludes the transforms taking place after YARV instructions are generated.</p>\n<p><em>Tokenization</em>, simply takes the Ruby code of a <em>.rb</em> file and converts it into a series of tokens ie. words from the Ruby programming language that it understands and identifiers, by iterating through characters. In fact, Ruby's C source, loops through each character and processes it based on what it is. Although it might seem that three steps listed earlier are sequential, tokenization and parsing happen at the same time; the parsing engine calls the tokenizer to retrieve tokens.</p>\n<p>Consider the first line of the given snippet --</p>\n<pre><code>    50.times do |n|\n        puts \"bitwise ${n}\"\n    end\n</code></pre>\n<p>As it iteratively loops through <code>5</code>, it realizes that it's at the start of a number and continues over to the <code>0</code> until it encounters its first non-numeric character. It then sees a <code>.</code> which actually is a numeric character, given that it could be part of a floating-point value. When it encounters <code>t</code>, a non-numeric character, it backtracks to the <code>.</code> and converts the <code>50</code> it saw into a token of type <code>tINTEGER</code>. It continues this process sequentially through the line, converting <code>times</code> to a token - <code>tIDENTIFIER</code>, <code>do</code> to a token - <code>keyword_do</code>, <code>n</code> to a token <code>tIDENTIFIER</code>. In a similar way, the entire script which is a character stream yields a token stream.</p>\n<pre><code>tINTEGER.tIDENTIFIER keyword_do | tIDENTIFIER |\n</code></pre>\n<p>It is presumed that the distinctions between keywords, reserved words and identifiers are understood by the reader. Internally, Ruby's C source maintains a table of these reserved words.</p>\n<p>A list of Ruby's keywords are defined at <a href=\"https://github.com/ruby/ruby/blob/master/defs/keywords\">defs/keywords</a>.</p>\n<h2>Grammars and Rules</h2>\n<p>The <a href=\"https://github.com/ruby/ruby/blob/master/parse.y\"><code>parser.y</code></a> file is a grammar rule file which contains the rules for the Ruby parser engine. This file is massive (13,315 LOC) and if you're familiar with C programming, you'd know it ought to have pointers and <code>structs</code> flying around all over. Considering our interest in tokenization specifically, the <code>parser_yylex</code> function should be within our purview (starts at line 8,888 <em>as of 17th May 2020</em>).</p>\n<p>The function prototype:</p>\n<pre><code>    static enum \n        yytokentype parser_yylex(struct parser_params *p);\n</code></pre>\n<p>Observe the switch statement</p>\n<pre><code>   retry:\n    last_state = p->lex.state;\n#ifndef RIPPER\n    token_flush(p);\n#endif\n    switch (c = nextc(p)) {\n        /*\n            contains cases for characters that may be\n            encountered while iterating through the\n            character stream while jumping to the\n            'retry' label everytime a whitespace\n            character is encountered\n        */\n        ...\n    }\n</code></pre>\n<p>The <code>nextc()</code> calls, as you would expect, return the next character in the stream.</p>\n<p>Another detail quoted straight from the book --</p>\n<p><em>Ruby doesn’t use the Lex tokenization tool that C programmers commonly use in conjunction with a parser generator like Yacc or Bison . Instead, the Ruby core team wrote the Ruby tokenization code by hand, whether for performance reasons or because Ruby’s tokenization rules required special logic that Lex couldn’t provide.</em></p>\n<h2>Tokenizing with <em>Ripper</em></h2>\n<p>It is quite a simple task to see tokenization in action. All that needs to be done is to require the <code>Ripper</code> class and pass to its <code>lex()</code> method a string containing the code as an argument.</p>\n<pre><code>    require 'ripper'\n    require 'pp'\n\n    source = &#x3C;&#x3C;STR\n        50.times do |n|\n            puts \"bitwise ${n}\"\n        end\n    STR\n\n    pp Ripper.lex(source)\n</code></pre>\n<h3>The tokenized output --</h3>\n<pre><code>[[[1, 0], :on_sp, \"\\t\", EXPR_BEG],\n [[1, 1], :on_int, \"50\", EXPR_END],\n [[1, 3], :on_period, \".\", EXPR_DOT],\n [[1, 4], :on_ident, \"times\", EXPR_ARG],\n [[1, 9], :on_sp, \" \", EXPR_ARG],\n [[1, 10], :on_kw, \"do\", EXPR_BEG],\n [[1, 12], :on_sp, \" \", EXPR_BEG],\n [[1, 13], :on_op, \"|\", EXPR_BEG|EXPR_LABEL],\n [[1, 14], :on_ident, \"n\", EXPR_ARG],\n [[1, 15], :on_op, \"|\", EXPR_BEG|EXPR_LABEL],\n [[1, 16], :on_ignored_nl, \"\\n\", EXPR_BEG|EXPR_LABEL],\n [[2, 0], :on_sp, \"\\t\\t\", EXPR_BEG|EXPR_LABEL],\n [[2, 2], :on_ident, \"puts\", EXPR_CMDARG],\n [[2, 6], :on_sp, \" \", EXPR_CMDARG],\n [[2, 7], :on_tstring_beg, \"\\\"\", EXPR_CMDARG],\n [[2, 8], :on_tstring_content, \"bitwise ${n}\", EXPR_CMDARG],\n [[2, 20], :on_tstring_end, \"\\\"\", EXPR_END],\n [[2, 21], :on_nl, \"\\n\", EXPR_BEG],\n [[3, 0], :on_sp, \"\\t\", EXPR_BEG],\n [[3, 1], :on_kw, \"end\", EXPR_END],\n [[3, 4], :on_nl, \"\\n\", EXPR_BEG]]\n</code></pre>\n<p><strong>Each element in the output array consists of an array with 4 elements:</strong></p>\n<ol>\n<li><code>[line_number, text_column_number]</code></li>\n<li><code>:the_token_type</code> as a Ruby Symbol <em>eg: <code>:on_nl, :on_kw</code></em></li>\n<li>The character(s) corresponding to the token <em>eg: <code>\"\\n\", \"end\"</code></em></li>\n<li>The <em>state</em> of the tokenizer as it iterates <em>eg: <code>EXPR_BEG, EXPR_CMDARG</code></em> (defined in the <code>Ripper</code> Class)</li>\n</ol>\n<h3>Some key aspects of tokenization:</h3>\n<ul>\n<li>Lookahead is utilized to ensure a distinction, for instance, between <strong><code>&#x3C;</code></strong>, less than operator and <strong><code>&#x3C;&#x3C;</code></strong>, the shovel operator</li>\n<li>Tokenization <strong>DOES NOT</strong> detect syntax errors; that is a responsibility of the parser.</li>\n</ul>\n<p>Read more about <a href=\"https://ruby-doc.org/stdlib-2.6.3/libdoc/ripper/rdoc/Ripper.html\">Ripper</a>.</p>\n<h4>Stay tuned for the next post which will entail the details of <em>Parsing</em>.</h4>\n<h4>Buy <em>\"Ruby Under a Microscope\"</em> on <a href=\"https://www.amazon.com/Ruby-Under-Microscope-Illustrated-Internals-ebook/dp/B00GK5P6L2\">Amazon</a>!</h4>\n<h2>References</h2>\n<ol>\n<li>Shaughnessy, P., n.d. Ruby Under A Microscope.</li>\n<li>Ruby-lang.org. 2020. About Ruby. [online] Available at: <a href=\"https://www.ruby-lang.org/en/about/\">https://www.ruby-lang.org/en/about/</a> [Accessed 18 May 2020].</li>\n<li>GitHub. 2020. Ruby/Spec. [online] Available at: <a href=\"https://github.com/ruby/spec\">https://github.com/ruby/spec</a> [Accessed 18 May 2020].</li>\n<li>GitHub. 2020. The Ruby Programming Language. [online] Available at: <a href=\"https://github.com/ruby\">https://github.com/ruby</a> [Accessed 18 May 2020].</li>\n<li>Ruby-doc.org. 2020. Class: Ripper (Ruby 2.6.3). [online] Available at: <a href=\"https://ruby-doc.org/stdlib-2.6.3/libdoc/ripper/rdoc/Ripper.html\">https://ruby-doc.org/stdlib-2.6.3/libdoc/ripper/rdoc/Ripper.html</a> [Accessed 18 May 2020].</li>\n</ol>","frontmatter":{"title":"Notes on \"Ruby Under A Microscope\" and more: Intro. & Tokenization","slug":"/skills/post-one","author":"John Appleseed"}}},"pageContext":{"slug":"/skills/post-one"}},"staticQueryHashes":["3649515864","63159454"]}